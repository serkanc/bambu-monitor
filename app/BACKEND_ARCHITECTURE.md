# Backend Architecture Contract

This document defines backend boundaries, lifecycle, and operational rules.
New backend code must follow this contract.

## Core vs Service Boundary

Core:
- Protocol/IO primitives (FTP, MQTT, Camera).
- Connection, parsing, timeouts.
- No store/state awareness.

Service:
- Workflow orchestration.
- Retry/backoff and reconnection loops.
- State sync and domain decisions.
- Calls core APIs and normalizes errors.
- Command builders and configuration services for API routes.

Rule: Core never imports services or store. Services call core only.

## Domain Exception Layer

Core raises protocol/IO exceptions.
Service catches and normalizes them into `DomainError` types.
API routes translate only `DomainError` into HTTP responses.

## Lifecycle (Startup/Shutdown)

All background services are controlled from `app/main.py`.
Use a single registry or task manager for:
- MQTT connect/disconnect
- FTPS reconnect loop
- Camera lifecycle

No service should auto-start on import.

## Device Context Dependency

API routes that operate on the active printer should prefer a single
`DeviceContext` dependency that bundles:
- active printer id
- state snapshot
- MQTT/FTPS/Camera services (when active)

This keeps route signatures small and ensures a consistent request-time view
of device state.

## Auth + Sessions

- API uses bearer tokens for non-session clients.
- Admin UI uses session cookies.
- `api_token`, `admin_token`, and `session_secret` are stored in `app.json`.
- Session secret rotation forces logout (requires restart).

## Logging + Request ID

Structured logs with `request_id` on all API requests.
Background tasks use `request_id=system` or a scoped tag (`bg:*`).

Logging levels:
- Expected failures (validation, cancel, parse issues) → `warning`/`info`, no trace.
- Unexpected failures → `error` + stack trace (`logger.exception`).
- Cancelled operations should never be logged as errors.

## State Lifecycle Boundary

State mutations must flow through `StateOrchestrator` to keep a single-writer
boundary. `StateRepository.update_store` is intended for orchestrator use only.

## Metrics + Alerts

Telemetry captures request latency and error rates.
Alert thresholds are centralized (see `core/telemetry.js` on frontend and backend metrics).

## Connection Orchestrator

Connection orchestration is centralized in `app/services/connection_orchestrator.py`:
- MQTT is the primary liveness source for the active printer.
- FTPS and Camera reconnect loops are gated based on MQTT health.
- Presence watchers for other printers remain independent but follow the same policy.

The orchestrator is started/stopped by `ServiceRegistry` and must be the only place
that coordinates cross-service reconnect logic.

## Debug Endpoints

Debug routes are guarded by a `debug_enabled` app setting and should be disabled
in production deployments.

## State Stream (SSE)

The backend exposes a state stream over SSE:
- Endpoint: `/api/state/stream` (token protected like other API routes).
- First event is a full snapshot (`event: snapshot`).
- Subsequent events are diffs (`event: diff`) with `changes` as path → value.
- Each event includes a monotonically increasing `version` per printer.
- If client falls behind, it should request a full snapshot again.

Diff format:
`{ version, ts, printer_id, changes: { "print.gcode_state": "...", ... } }`

## Data Paths

### `data/print-cache/`
Stores cached print artifacts and transient files for file transfer operations.
Treat as ephemeral cache; safe to clear if corrupted.

### `data/filament/`
Generated by tools under `tools/filament/*`.
Contains filament metadata snapshots used by UI.

### `data/hms/`
Generated by tooling/ingestion steps for HMS (health monitoring system) data.
Do not hand-edit; regenerate using tools when needed.
